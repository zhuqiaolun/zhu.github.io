{"meta":{"title":"zhuqiaolun - 个人博客","subtitle":"","description":"zhuqiaolun的个人博客","author":"zhuqiaolun","url":"https://www.zhuqiaolun.com","root":"/"},"pages":[{"title":"","date":"2020-05-29T13:27:29.411Z","updated":"2020-05-29T13:21:34.674Z","comments":true,"path":"baidu_verify_KzupUF583A.html","permalink":"https://www.zhuqiaolun.com/baidu_verify_KzupUF583A.html","excerpt":"","text":"KzupUF583A document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"404 Not Found：该页无法显示","date":"2020-05-21T07:27:09.976Z","updated":"2020-05-21T02:45:41.758Z","comments":false,"path":"/404.html","permalink":"https://www.zhuqiaolun.com/404.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"关于","date":"2020-05-29T10:28:09.204Z","updated":"2020-05-29T10:28:09.117Z","comments":false,"path":"about/index.html","permalink":"https://www.zhuqiaolun.com/about/index.html","excerpt":"","text":"{ \"NickName\": \"朱桥轮\", \"Gender\": \"男\", \"Birth\": \"辛未\", \"Profession\": \"Java开发工程师\", \"Language\": \"简体中文\", \"Website\": \"www.zhuqiaolun.com\", \"Locations\": { \"Country\": \"中国\", \"Province\": \"上海\", \"City\": \"浦东新区\" }, \"Interests\": [ \"游戏\", \"音乐\", \"电影\", \"动漫\" ] } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"书单","date":"2020-05-21T07:28:28.885Z","updated":"2020-05-21T07:28:28.842Z","comments":false,"path":"books/index.html","permalink":"https://www.zhuqiaolun.com/books/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"分类","date":"2020-05-21T06:52:06.850Z","updated":"2020-05-21T02:45:41.761Z","comments":false,"path":"categories/index.html","permalink":"https://www.zhuqiaolun.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"图册","date":"2020-05-31T12:33:40.065Z","updated":"2020-05-31T12:33:39.986Z","comments":true,"path":"gallery/index.html","permalink":"https://www.zhuqiaolun.com/gallery/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"友情链接","date":"2020-05-31T12:30:15.572Z","updated":"2020-05-31T12:30:15.507Z","comments":true,"path":"links/index.html","permalink":"https://www.zhuqiaolun.com/links/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"Repositories","date":"2020-05-21T06:48:44.225Z","updated":"2020-05-21T02:45:41.763Z","comments":false,"path":"repository/index.html","permalink":"https://www.zhuqiaolun.com/repository/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"标签","date":"2020-05-21T06:53:21.014Z","updated":"2020-05-21T02:45:41.765Z","comments":false,"path":"tags/index.html","permalink":"https://www.zhuqiaolun.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"hello","slug":"1595905368398-hello","date":"2020-07-28T03:02:48.000Z","updated":"2020-07-28T03:02:48.466Z","comments":true,"path":"2020/07/28/1595905368398-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/07/28/1595905368398-hello/","excerpt":"hello","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"hello","slug":"hello","permalink":"https://www.zhuqiaolun.com/categories/hello/"}],"tags":[{"name":"hello","slug":"hello","permalink":"https://www.zhuqiaolun.com/tags/hello/"}]},{"title":"kafka搭建 四 （SpringBoot调用）","slug":"1595654393778-hello","date":"2020-07-25T05:19:53.000Z","updated":"2020-07-25T06:24:14.582Z","comments":true,"path":"2020/07/25/1595654393778-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/07/25/1595654393778-hello/","excerpt":"SpringBoot调用kafka服务","text":"依赖引入1234567891011121314151617181920212223&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;!-- kafka start --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- kafka end --&gt; &lt;!-- fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt; yml配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950spring: # 基本配置 kafka: # 以逗号分隔的地址列表，用于建立与 Kafka 集群的初始连接 (kafka 默认的端口号为 9092) bootstrap-servers: 127.0.0.1:9092 # 定义生产者 producer: client-id: kafka.client.id # 发生错误后，消息重发的次数。 retries: 0 #当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算。 batch-size: 16384 # 设置生产者内存缓冲区的大小。 buffer-memory: 33554432 # 键的序列化方式 key-serializer: org.apache.kafka.common.serialization.StringSerializer # 值的序列化方式 value-serializer: org.apache.kafka.common.serialization.StringSerializer # acks=0 ： 生产者在成功写入消息之前不会等待任何来自服务器的响应。 # acks=1 ： 只要集群的首领节点收到消息，生产者就会收到一个来自服务器成功响应。 # acks=all ：只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。 acks: 1 # 定义消费者 consumer: # 自动提交的时间间隔 在 spring boot 2.X 版本中这里采用的是值的类型为 Duration 需要符合特定的格式，如 1S,1M,2H,5D auto-commit-interval: 3S # 该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该作何处理： # latest（默认值）在偏移量无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录） # earliest ：在偏移量无效的情况下，消费者将从起始位置读取分区的记录 auto-offset-reset: earliest # 是否自动提交偏移量，默认值是 true,为了避免出现重复数据和数据丢失，可以把它设置为 false,然后手动提交偏移量 enable-auto-commit: true # 键的反序列化方式 key-deserializer: org.apache.kafka.common.serialization.StringDeserializer # 值的反序列化方式 value-deserializer: org.apache.kafka.common.serialization.StringDeserializer listener: # 在侦听器容器中运行的线程数(消费者个数即可) concurrency: 5 demon: #消费者配置 mqConfig: # 监听的主题topic topics: test,first,second,third topic: # 监听的主题first的消息执行类 first: com.demon.springbootkafka.listener.consumer.message.FirstMessage # 监听的主题second的消息执行类 second: com.demon.springbootkafka.listener.consumer.message.SecondMessage 类配置mq的消费者配置类： 123456789101112/** * @className: MqProperties.java * @description: mq的消费者配置类，映射 配置文件里面的值 * @author: Demon * @date 2020/6/16 18:00 */@Component@ConfigurationProperties(prefix = \"demon.mqConfig\")@Datapublic class MqConsumerTopicConfig { Map&lt;String,Class&lt;?&gt;&gt; topic;} 生产者KafKaProducerService 123456789101112131415161718192021222324252627282930313233343536373839404142package com.demon.springbootkafka.service;import java.util.concurrent.ExecutionException;import java.util.concurrent.TimeoutException;/** * @ClassName: KafKaProducerService * @Description: 生产者service * @Author: Demon * @Date: 2020/4/23 13:38 */public interface KafKaProducerService { /** * 发送标准消息没有回执 * @param topic 主题 * @param key key * @param data 内容 */ void sendStandardMessage(String topic, String key, String data); /** * 发送标准消息同步有阻塞 * @param topic 主题 * @param key key * @param data 内容 * @return 返回 * @throws InterruptedException 异常 * @throws ExecutionException 异常 * @throws TimeoutException 异常 */ Long sendStandardMessageSync(String topic, String key, String data) throws InterruptedException, ExecutionException, TimeoutException; /** * 发送标准消息异步无阻塞 * @param topic 主题 * @param key key * @param data 内容 */ void sendStandardMessageAsync(String topic, String key, String data);} KafKaProducerServiceImpl: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.demon.springbootkafka.service.impl;import lombok.extern.slf4j.Slf4j;import org.apache.kafka.clients.producer.ProducerRecord;import org.springframework.kafka.core.KafkaTemplate;import org.springframework.kafka.support.SendResult;import org.springframework.stereotype.Service;import org.springframework.util.concurrent.ListenableFuture;import org.springframework.util.concurrent.ListenableFutureCallback;import javax.annotation.Resource;import java.util.concurrent.ExecutionException;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;/** * @ClassName: KafKaProducerServiceImpl * @Description: 生产者service的实现，负责执行消息发送 * @Author: Demon * @Date: 2020/4/23 13:38 */@Slf4j@Servicepublic class KafKaProducerServiceImpl implements com.demon.springbootkafka.service.KafKaProducerService { @Resource private KafkaTemplate&lt;String, String&gt; kafkaTemplate; /** * 构建待发送的消息 * @param topic topic * @param key key * @param data data * @return 返回 */ private ProducerRecord&lt;String, String&gt; getRecord(String topic, String key, String data){ if(key == null){ return new ProducerRecord&lt;&gt;(topic,data); }else{ return new ProducerRecord&lt;&gt;(topic,key,data); } } @Override public void sendStandardMessage(String topic, String key, String data){ kafkaTemplate.send(getRecord(topic,key,data)); } @Override public Long sendStandardMessageSync(String topic, String key, String data) throws InterruptedException, ExecutionException, TimeoutException { SendResult&lt;String, String&gt; stringStringSendResult = kafkaTemplate.send(getRecord(topic, key, data)).get(1, TimeUnit.SECONDS); System.out.println(stringStringSendResult.getProducerRecord().timestamp()); return stringStringSendResult.getProducerRecord().timestamp(); } @Override public void sendStandardMessageAsync(String topic, String key, String data) { ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; sendResultListenableFuture = kafkaTemplate.send(getRecord(topic,key,data)); // 发送消息回调 //noinspection NullableProblems sendResultListenableFuture.addCallback(new ListenableFutureCallback&lt;SendResult&lt;String, String&gt;&gt;() { /** 发送成功回调方法 */ @Override public void onSuccess(SendResult&lt;String, String&gt; sendResultMap) { log.debug(\"发送消息成功：\" + sendResultMap); } /** 发送失败回调方法 */ @Override public void onFailure(Throwable throwable) { log.debug(\"发送消息失败：\"+ throwable.getMessage()); } }); }} 生产者监听KafkaSendResultHandler： 12345678910111213141516171819202122232425262728package com.demon.springbootkafka.listener.producer;import lombok.extern.slf4j.Slf4j;import org.apache.kafka.clients.producer.ProducerRecord;import org.apache.kafka.clients.producer.RecordMetadata;import org.springframework.kafka.support.ProducerListener;import org.springframework.stereotype.Component;/** * @ClassName: KafkaSendResultHandler * @Description: 发送消息结果回调 * @Author: Demon * @Date: 2020/4/23 13:55 */@Slf4j@Componentpublic class KafkaSendResultHandler implements ProducerListener { @Override public void onSuccess(ProducerRecord producerRecord, RecordMetadata recordMetadata) { log.info(\"发送消息监听成功 : \" + producerRecord.toString()); } @Override public void onError(ProducerRecord producerRecord, Exception exception) { log.info(\"发送消息监听失败 : \" + exception); }} 消费者KafkaConsumerService： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.demon.springbootkafka.listener.consumer;import com.demon.springbootkafka.config.MqConsumerTopicConfig;import lombok.extern.slf4j.Slf4j;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.springframework.kafka.annotation.KafkaListener;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.lang.reflect.Method;/** * @ClassName: KafkaConsumerService * @Description: 消费者监听消息,通过类的反射执行topic消息处理 * @Author: Demon * @Date: 2020/4/23 14:44 */@Slf4j@Componentpublic class KafkaConsumerService { @Resource private MqConsumerTopicConfig mqConsumerTopicConfig; @KafkaListener(topics = \"#{'${demon.mqConfig.topics}'.split(',')}\", groupId = \"test-group\") public void receive(ConsumerRecord&lt;String, Object&gt; record) { String topic = record.topic(); log.info(\"------ \" + topic + \" 消费者处理消息------\"); try { if (mqConsumerTopicConfig.getTopic().containsKey(topic)) { String classPath = mqConsumerTopicConfig.getTopic().get(topic).getName(); try { Class&lt;?&gt; c1s = Class.forName(classPath); //判断是否有实现ConsumerMessageExecute消息处理接口，否则不予执行 if (c1s.getInterfaces().length &gt; 0 &amp;&amp; c1s.getInterfaces()[0].equals(ConsumerMessageExecute.class)) { //获得Class的Method对象,参数为方法名,参数列表的类型Class对象 Method method = c1s.getMethod(\"execute\", ConsumerRecord.class); //invoke方法，参数为cls实例对象，和想要调用的方法参数 Boolean value = (Boolean) method.invoke(c1s.newInstance(), record); //输出invoke方法的返回值 System.out.println(\"execute方法的返回值：\" + value); } else { log.error(\"============ 调用class：{} 错误:{}\", classPath, \"此类没有实现 MessageExecute 接口！！！\"); } } catch (Exception e) { e.printStackTrace(); log.error(\"============ 调用class：{} 异常：{}\", classPath, e); } } else { log.error(\"============ {}不存在\", topic); } } catch (Exception e) { e.printStackTrace(); } }} ConsumerMessageExecute： 1234567891011121314151617181920package com.demon.springbootkafka.listener.consumer;import org.apache.kafka.clients.consumer.ConsumerRecord;/** * 消息执行统一接口 * @ClassName: MessageExecute * @Description: 消息实现接口，必须实现此接口，否则无法执行消息处理 * @Author: Demon * @Date: 2020/5/24 12:55 */public interface ConsumerMessageExecute { /** * 消费者 消息执行方法 * @param record 消息体 * @return 返回 */ boolean execute(ConsumerRecord&lt;String, Object&gt; record);} FirstMessage: 123456789101112131415161718package com.demon.springbootkafka.listener.consumer.message;import com.demon.springbootkafka.listener.consumer.ConsumerMessageExecute;import org.apache.kafka.clients.consumer.ConsumerRecord;/** * @ClassName: FirstMessage * @Description: 监听topic【first】的处理 * @Author: Demon * @Date: 2020/6/17 19:14 */public class FirstMessage implements ConsumerMessageExecute { @Override public boolean execute(ConsumerRecord&lt;String, Object&gt; record) { System.out.println(String.format(\"topic = %s, key = %s, value = %s \",record.topic(), record.key(), record.value())); return true; }} SecondMessage: 123456789101112131415161718package com.demon.springbootkafka.listener.consumer.message;import com.demon.springbootkafka.listener.consumer.ConsumerMessageExecute;import org.apache.kafka.clients.consumer.ConsumerRecord;/** * @ClassName: MessageUrgent * @Description: 监听topic【second】的处理 * @Author: Demon * @Date: 2020/6/17 19:15 */public class SecondMessage implements ConsumerMessageExecute { @Override public boolean execute(ConsumerRecord&lt;String, Object&gt; record) { System.out.println(String.format(\"topic = %s, key = %s, value = %s \",record.topic(), record.key(), record.value())); return true; }} 测试SpringBootKafkaApplicationTests： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.demon.springbootkafka;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.demon.springbootkafka.service.KafKaProducerService;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import javax.annotation.Resource;import java.util.UUID;import java.util.concurrent.ExecutionException;import java.util.concurrent.TimeoutException;@SpringBootTestclass SpringBootKafkaApplicationTests { @Resource private KafKaProducerService kafKaProducerService; @Test void contextLoads() { System.out.println(System.currentTimeMillis()); } @Test void sendStandardMessage() { String topic = \"test\"; String key = UUID.randomUUID().toString(); String data = JSON.toJSONString(new JSONObject().put(\"time\",System.currentTimeMillis())); kafKaProducerService.sendStandardMessage(topic,key,data); } @Test void sendStandardMessageAsync() { String topic = \"test\"; String key = UUID.randomUUID().toString(); String data = JSON.toJSONString(new JSONObject().put(\"time\",System.currentTimeMillis())); kafKaProducerService.sendStandardMessageAsync(topic,key,data); } @Test void sendStandardMessageSync() { String topic = \"test\"; String key = UUID.randomUUID().toString(); JSONObject jsonObject = new JSONObject(true); jsonObject.put(\"time\",System.currentTimeMillis()); String data = jsonObject.toJSONString(); try { kafKaProducerService.sendStandardMessageSync(topic, key, data); } catch (InterruptedException | TimeoutException | ExecutionException e) { e.printStackTrace(); } }} 扩展KafkaConfig: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.demon.springbootkafka.config;import org.apache.kafka.clients.admin.AdminClient;import org.apache.kafka.clients.admin.AdminClientConfig;import org.springframework.boot.autoconfigure.kafka.KafkaProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.kafka.annotation.EnableKafka;import org.springframework.kafka.core.KafkaAdmin;import javax.annotation.Resource;import java.util.HashMap;import java.util.Map;/** * @ClassName: KafkaConfig * @Description: KafkaConfig 配置,操作topic * @Author: Demon * @Date: 2020/4/23 18:28 */@Configuration@EnableKafkapublic class KafkaConfig { @Resource private KafkaProperties kafkaProperties; /** * 创建一个kafka管理类，相当于rabbitMQ的管理类rabbitAdmin, * 没有此bean无法自定义的使用adminClient创建topic * @return 返回 */ @Bean public KafkaAdmin kafkaAdmin() { Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(1); //配置Kafka实例的连接地址 //kafka的地址，不是zookeeper props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaProperties.getBootstrapServers().get(0)); return new KafkaAdmin(props); } /** * kafka客户端，在spring中创建这个bean之后可以注入并且创建topic, * 用于集群环境，创建对个副本 * @return 返回 */ @Bean public AdminClient adminClient() { return AdminClient.create(kafkaAdmin().getConfig()); }} SpringBootKafkaApplicationTests_topic: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.demon.springbootkafka;import com.alibaba.fastjson.JSON;import org.apache.kafka.clients.admin.*;import org.junit.jupiter.api.Test;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.annotation.Resource;import java.util.ArrayList;import java.util.Collections;import java.util.Set;import java.util.concurrent.ExecutionException;@SpringBootTest@EnableAutoConfigurationclass SpringBootKafkaApplicationTests_topic { @Resource private AdminClient adminClient; @Test void contextLoads() { System.out.println(System.currentTimeMillis()); } @Test void listTopics(){ try { ListTopicsResult listTopics = adminClient.listTopics(); Set&lt;String&gt; topics = listTopics.names().get(); for (String topic : topics) { System.out.println(topic); } } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } @Test void createTopic() { ArrayList&lt;NewTopic&gt; topics = new ArrayList&lt;&gt;(); NewTopic newTopic = new NewTopic(\"test1\", 2, (short) 1); topics.add(newTopic); CreateTopicsResult result = adminClient.createTopics(topics); System.out.println( JSON.toJSONString(result)); } @Test void deleteTopics() { DeleteTopicsResult deleteTopicsResult = adminClient.deleteTopics(Collections.singletonList(\"test1\")); System.out.println( JSON.toJSONString(deleteTopicsResult)); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"queue队列","slug":"queue队列","permalink":"https://www.zhuqiaolun.com/categories/queue%E9%98%9F%E5%88%97/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://www.zhuqiaolun.com/tags/kafka/"}]},{"title":"kafka搭建 三 （Java普通调用）","slug":"1595649722982-hello","date":"2020-07-25T04:02:02.000Z","updated":"2020-07-25T05:13:40.045Z","comments":true,"path":"2020/07/25/1595649722982-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/07/25/1595649722982-hello/","excerpt":"Java调用kafka服务","text":"依赖引入1234567891011121314151617181920212223242526&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt;&lt;/dependency&gt; Topic操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.util.ArrayList;import java.util.Collections;import java.util.Properties;import java.util.Set;import java.util.concurrent.ExecutionException;import org.apache.kafka.clients.CommonClientConfigs;import org.apache.kafka.clients.admin.AdminClient;import org.apache.kafka.clients.admin.CreateTopicsResult;import org.apache.kafka.clients.admin.DeleteTopicsResult;import org.apache.kafka.clients.admin.ListTopicsResult;import org.apache.kafka.clients.admin.NewTopic;import org.junit.After;import org.junit.Before;import org.junit.Test;import com.alibaba.fastjson.JSONObject;/** * Topic操作 */public class CreateTopics { private static AdminClient adminClient = null; /** * 初始化adminClient */ @Before public void getAdminClient() { Properties props = new Properties(); props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, \"127.0.0.1:9092\"); adminClient = AdminClient.create(props); } /** * 获取所有Topic */ @Test public void getTopicList() { try { ListTopicsResult listTopics = adminClient.listTopics(); Set&lt;String&gt; topics = listTopics.names().get(); for (String topic : topics) { System.out.println(topic); } } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } /** * 创建Topic 创建了3个名为\"first\", \"second\",\"third\"，分区数为1，复制因子为1的Topic. * 创建完成，返回null */ @Test public void getCreateTopic() { ArrayList&lt;NewTopic&gt; topics = new ArrayList&lt;NewTopic&gt;(); topics.add(new NewTopic(\"test\", 4, (short) 1)); topics.add(new NewTopic(\"first\", 4, (short) 1)); topics.add(new NewTopic(\"second\", 4, (short) 1)); topics.add(new NewTopic(\"third\", 4, (short) 1)); CreateTopicsResult result = adminClient.createTopics(topics); try { System.out.println(result.all().get()); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } /** * 删除Topic */ @Test public void getDeleteTopic() { DeleteTopicsResult deleteTopicsResult =adminClient.deleteTopics(Collections.singleton(\"test\")); System.out.println(JSONObject.toJSONString(deleteTopicsResult)); } /** * 关闭连接 */ @After public void afterClass() { adminClient.close(); }} 生产者普通生产者1234567891011121314public static void testProducer(String topic) { Properties props = new Properties(); props.put(\"bootstrap.servers\", \"127.0.0.1:9092\"); props.put(\"acks\", \"all\"); props.put(\"retries\", 0); props.put(\"batch.size\", 16384); props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;String, String&gt;(props); for (int i = 0; i &lt; 10; i++) { producer.send(new ProducerRecord&lt;String, String&gt;(topic, Integer.toString(i), Integer.toString(i))); } producer.close();} 事务生产者12345678910111213141516171819202122232425public static void testTransactionProducer(String topic) { Properties props = new Properties(); props.put(\"bootstrap.servers\", \"127.0.0.1:9092\"); props.put(\"transactional.id\", \"my-transactional-id\"); props.put(\"acks\", \"all\"); props.put(\"batch.size\", 16384); KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props, new StringSerializer(),new StringSerializer()); producer.initTransactions(); try { producer.beginTransaction(); for (int i = 0; i &lt; 3; i++) { producer.send(new ProducerRecord&lt;&gt;(topic, Integer.toString(i), Integer.toString(i))); } producer.commitTransaction(); } catch (ProducerFencedException | OutOfOrderSequenceException | AuthorizationException e) { // We can't recover from these exceptions, so our only option is to close the // producer and exit. producer.close(); } catch (KafkaException e) { // For all other exceptions, just abort the transaction and try again. producer.abortTransaction(); } finally { producer.close(); }} 消费者1234567891011121314151617181920212223242526272829303132333435import java.time.Duration;import java.util.Arrays;import java.util.Properties;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.apache.kafka.clients.consumer.ConsumerRecords;import org.apache.kafka.clients.consumer.KafkaConsumer;public class CustomConsumer { public static void main(String[] args) { Properties props = new Properties(); // 定义kakfa 服务的地址，不需要将所有broker指定上 props.put(\"bootstrap.servers\", \"127.0.0.1:9092\"); // 制定consumer group props.put(\"group.id\", \"custom_group_id\"); // 是否自动确认offset props.put(\"enable.auto.commit\", \"true\"); // 自动确认offset的时间间隔 props.put(\"auto.commit.interval.ms\", \"1000\"); // key的序列化类 props.put(\"key.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\"); // value的序列化类 props.put(\"value.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\"); // 定义consumer KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props); // 消费者订阅的topic, 可同时订阅多个 consumer.subscribe(Arrays.asList(\"test\",\"first\", \"second\",\"third\")); while (true) { // 读取数据，读取超时时间为100ms ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100)); for (ConsumerRecord&lt;String, String&gt; record : records) System.out.printf(\"offset = %d, key = %s, value = %s%n\", record.offset(), record.key(), record.value()); } }} 集群使用在配置中将bootstrap.servers，修改以下方式即可，需要将所有broker指定写上 1props.put(\"bootstrap.servers\", \"127.0.0.1:9092,127.0.0.2:9092,127.0.0.3:9092\"); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"queue队列","slug":"queue队列","permalink":"https://www.zhuqiaolun.com/categories/queue%E9%98%9F%E5%88%97/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://www.zhuqiaolun.com/tags/kafka/"}]},{"title":"kafka搭建 二 （集群）","slug":"1595582052033-hello","date":"2020-07-24T09:14:12.000Z","updated":"2020-07-25T05:12:07.153Z","comments":true,"path":"2020/07/24/1595582052033-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/07/24/1595582052033-hello/","excerpt":"kafka集群搭建 - 使用内置Zookeeper","text":"下载官网下载地址：http://kafka.apache.org/downloads.html下载完成后复制一式三份，完成集群部署至少需要三台以及三台以上的服务。 kafka版本:kafka_2.12-2.5.0三台主机IP 127.0.0.1、127.0.0.2、127.0.0.3 kafka配置第一台server.properties： 12345678# 唯一值broker.id=1listeners=PLAINTEXT://127.0.0.1:9092# 建议填写服务器的数量值num.partitions=3 # 其他zk服务的连接zookeeper.connect=127.0.0.1:2181,127.0.0.2:2181,127.0.0.3:2181zookeeper.connection.timeout.ms=30000 第二台server.properties： 12345678# 唯一值broker.id=2listeners=PLAINTEXT://127.0.0.2:9092# 建议填写服务器的数量值num.partitions=3 # 其他zk服务的连接zookeeper.connect=127.0.0.1:2181,127.0.0.2:2181,127.0.0.3:2181zookeeper.connection.timeout.ms=30000 第三台server.properties： 12345678# 唯一值broker.id=3listeners=PLAINTEXT://127.0.0.3:9092# 建议填写服务器的数量值num.partitions=3 # 其他zk服务的连接zookeeper.connect=127.0.0.1:2181,127.0.0.2:2181,127.0.0.3:2181zookeeper.connection.timeout.ms=30000 zookeeper配置zookeeper可统一配置，zookeeper.properties： 12345678910111213dataDir=D:\\\\kafka_2.12-2.5.0\\\\data\\\\zookeeperdataLogDir=D:\\\\kafka_2.12-2.5.0\\\\logs\\\\zookeeperclientPort=2181# maxClientCnxns = 0 # 注释掉该配置admin.enableServer=false#设置连接参数，添加如下配置tickTime=2000initLimit=10syncLimit=5#设置broker Id的服务地址server.1=127.0.0.1:2888:3888server.2=127.0.0.2:2888:3888server.3=127.0.0.3:2888:3888同时在zookeeper数据目录dataDir下添加id配置，在各台服务的zookeeper数据目录添加myid文件且无后缀名，写入各自服务broker.id属性值， document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"queue队列","slug":"queue队列","permalink":"https://www.zhuqiaolun.com/categories/queue%E9%98%9F%E5%88%97/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://www.zhuqiaolun.com/tags/kafka/"}]},{"title":"kafka搭建 一 （单机）","slug":"1595581721604-hello","date":"2020-07-24T09:08:41.000Z","updated":"2020-07-24T10:45:16.418Z","comments":true,"path":"2020/07/24/1595581721604-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/07/24/1595581721604-hello/","excerpt":"kafka搭建 - 使用内置Zookeeper","text":"前言在刚开始学习Kafka的时候，安装Kafka时说Kafka依赖ZooKeeper，所以想要安装Kafka必须先安装ZooKeeper。但是在下载Kafka的时候，官网上说，Kafka 0.5.x版本以上已经自带ZooKeeper，不需要自己安装ZooKeeper。但在使用自带ZooKeeper也没有啥缺陷，反倒针对特定版本人家 Kafka 已经验证过其稳定性了。 下载官网下载地址：http://kafka.apache.org/downloads.html 配置解压文件打开 kafka_2.12-2.5.0\\config从文本编辑器里打开 server.properties,添加或者修改内容 12345listeners=PLAINTEXT://10.200.47.142:9092log.dirs=D:\\\\kafka_2.12-2.5.0\\\\logs\\\\kafkanum.partitions=4zookeeper.connect=127.0.0.1:2181zookeeper.connection.timeout.ms=30000 端口号可以被任意修改。如果端口号设置为小于1024，那么kafka需要以root身份启动，不指定的话，按照默认9092【service.properties】port = 19092【connect-distributed.properties 】bootstrap.servers=localhost:19092【producer.properties 】bootstrap.servers=localhost:19092【connect-standalone.properties 】bootstrap.servers=localhost:19092【consumer.properties 】bootstrap.servers=localhost:19092 从文本编辑器里打开 zookeeper.properties,添加或者修改内容 12dataDir=D:\\\\kafka_2.12-2.5.0\\\\data\\\\zookeeperdataLogDir=D:\\\\kafka_2.12-2.5.0\\\\logs\\\\zookeeper 启动在根目录下编写bat文件启动： 1.start-zookeeper.bat内容如下： 12@echo offstart cmd /c \"title zookeeper-21810 &amp;&amp; .\\bin\\windows\\zookeeper-server-start .\\config\\zookeeper.properties\" 2.start-kafka.bat 12@echo offstart cmd /c \"title kafka_2.11-2.4.1-9092 &amp;&amp; .\\bin\\windows\\kafka-server-start.bat .\\config\\server.properties\" 按照顺序启动，即可执行， document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"queue队列","slug":"queue队列","permalink":"https://www.zhuqiaolun.com/categories/queue%E9%98%9F%E5%88%97/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://www.zhuqiaolun.com/tags/kafka/"}]},{"title":"发布Java程序为Windows服务 三","slug":"1592899073321-hello","date":"2020-06-23T07:57:53.000Z","updated":"2020-06-23T08:50:57.509Z","comments":true,"path":"2020/06/23/1592899073321-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/06/23/1592899073321-hello/","excerpt":"使用 Java Service Wrapper 注册Windows服务（修改配置参数，新增对 jvm 的配置）","text":"前面是使用的配置会导致JVM不断重启，需要加JVM参数以及设置，同时设置服务开机启动； 配置文件新增配置参数如下： wrapper.jmx=false wrapper.on_exit.0=SHUTDOWN wrapper.on_exit.default=RESTART wrapper.ntservice.interactive = true # 服务开机启动 wrapper.ntservice.starttype=AUTO_START wrapper.tray = true # 监测JVM死锁 wrapper.java.monitor.deadlock = true wrapper.java.monitor.heap = true wrapper.java.monitor.gc.restart = true # Java Heap 初始化大小(单位：MB) wrapper.java.initmemory=128 # Java Heap 最大值(单位：MB) wrapper.java.maxmemory=128 # 32/64位选择，true为自动选择 wrapper.java.additional.auto_bits=TRUE检测JVM参数可以用jps+jmap监测即可jps:jmap -heap xxxxx document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Windows10","slug":"Windows10","permalink":"https://www.zhuqiaolun.com/categories/Windows10/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.zhuqiaolun.com/tags/Java/"}]},{"title":"发布Java程序为Windows服务 二","slug":"1592898236483-hello","date":"2020-06-23T07:43:56.000Z","updated":"2020-06-23T07:57:19.579Z","comments":true,"path":"2020/06/23/1592898236483-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/06/23/1592898236483-hello/","excerpt":"使用 Java Service Wrapper 注册Windows服务（不含有Java环境）","text":"前面在有Java环境的情况下的设置，现在假设我们不存在Java运行环境，也就是没有JRE与JDK，所以需要拷贝java安装目录下的JRE（包含bin目录和相关lib）目录到需要的服务目录下 拷贝JREJRE目录拷贝JRE目录到服务目录 修改配置文件利用拷贝过去的jre目录下的jar包和bin\\java.exe，修改wrapper.java.command的值 wrapper.java.command=../jre1.8.0_45/bin/java.exe document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Windows10","slug":"Windows10","permalink":"https://www.zhuqiaolun.com/categories/Windows10/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.zhuqiaolun.com/tags/Java/"}]},{"title":"发布Java程序为Windows服务 一","slug":"1592889892770-hello","date":"2020-06-23T05:24:52.000Z","updated":"2020-06-23T08:24:59.067Z","comments":true,"path":"2020/06/23/1592889892770-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/06/23/1592889892770-hello/","excerpt":"使用 Java Service Wrapper 注册Windows服务（含有Java环境）","text":"描述有时候我们希望我们java写的程序作为服务注册到系统中，Java Service Wrapper 是目前较为流行的将Java程序部署成Windows服务的解决方案 下载serviceWrapper包网址：https://www.krenger.ch/blog/category/windows/ 下载zip压缩文件 解压serviceWrapper包解压wrapper-windows-x86-64-3.5.43.zip解压出来的文件多，但有些不是必须要的 注册一个简单的服务准备一个目录 建议在非中文且不含有空格的目录下目录结构如下：lang目录是存放支持其他语言的语言包，一般用不到mylib目录是存放我们的程序包 然后将下载的wrapper目录下的文件拷贝到我们上面建的目录: ···\\bin\\InstallTestWrapper-NT.bat -&gt; D:\\test\\java-service-hello\\bin\\InstallTestWrapper-NT.bat ···\\bin\\StartTestWrapper-NT.bat -&gt; D:\\test\\java-service-hello\\bin\\StartTestWrapper-NT.bat ···\\bin\\StopTestWrapper-NT.bat -&gt; D:\\test\\java-service-hello\\bin\\StopTestWrapper-NT.bat ···\\bin\\TestWrapper.bat -&gt; D:\\test\\java-service-hello\\bin\\TestWrapper.bat ···\\bin\\UninstallTestWrapper-NT.bat -&gt; D:\\test\\java-service-hello\\bin\\UninstallTestWrapper-NT.bat ···\\bin\\wrapper.exe -&gt; D:\\test\\java-service-hello\\bin\\wrapper.exe ···\\conf\\wrapper.conf -&gt; D:\\test\\java-service-hello\\conf\\wrapper.conf ···\\lib\\wrapper.jar -&gt; D:\\test\\java-service-hello\\lib\\wrapper.jar ···\\lib\\wrapper.dll -&gt; D:\\test\\java-service-hello\\lib\\wrapper.dlljava程序123456789101112131415161718192021222324import java.io.File;import java.util.concurrent.TimeUnit;import cn.hutool.core.date.DateUtil;import cn.hutool.core.io.file.FileAppender;import cn.hutool.core.lang.UUID;public class JarHelloApp { public static void main(String[] args) { while (true) { try { System.out.println(\"Hello World!\"); String str = UUID.fastUUID().toString(); System.out.println(str); //每隔3秒创建文件并写入内容 FileAppender appender = new FileAppender(new File(\"D:\\\\test\\\\jar\\\\\"+str+\".txt\"), 16, true); TimeUnit.SECONDS.sleep(3); appender.append(DateUtil.now()); appender.flush(); appender.toString(); } catch (Exception e) { e.printStackTrace(); } } }} 引入的依赖 12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.3.7&lt;/version&gt;&lt;/dependency&gt; java程序打包由于采用eclipse所有打包流程：项目邮件 -&gt; Export -&gt; Java/Runnable JAR file -&gt; Next 导出项目设置 导出项目文件 将程序打成的包以及自己程序依赖的包放到mylib 修改配置文件文件路径：D:\\test\\java-service-hello\\conf\\wrapper.conf内容如下： # jdk或者jre的java.exe路径，可通过环境变量获取 wrapper.java.command=%JAVA_HOME%/bin/java.exe # wrapper.java.command=C:\\Java\\jre1.8.0_45\\bin\\java # 日志级别 wrapper.java.command.loglevel=INFO wrapper.java.mainclass=org.tanukisoftware.wrapper.WrapperSimpleApp # 执行的程序的main方法的类的路径 wrapper.app.parameter.1=com.yetech.jar_hello.JarHelloApp # 依赖的包，第一个是wrapper包，第二个是自己打的包以及程序依赖包 wrapper.java.classpath.1=../lib/wrapper.jar wrapper.java.classpath.2=../mylib/*.jar # 固定写法，依赖的wrapper的包 wrapper.java.library.path.1=../lib # 日志配置 按照日期每天创建文件 wrapper.logfile=../logs/wrapper.YYYYMMDD.log wrapper.logfile.rollmode=DATE # 服务名称以及描述信息 wrapper.console.title=jar hello Server wrapper.name=jarhelloserver wrapper.displayname=jar hello Server wrapper.description=jar hello Server # 更多配置可对 jvm 配置测试注册服务在服务目录下的bin目录下双击 TestWrapper.bat 文件，当程序执行正确时则表示可以注册服务控制台测试 注册服务在服务目录下执行（管理员模式） 注册服务命令 bin\\wrapper.exe -i ..\\conf\\wrapper.confcmd结果服务结果 启动服务命令 net start jarhelloserver 或者 bin\\wrapper.exe -t ..\\conf\\wrapper.confcmd结果服务结果 停止服务命令 net stop jarhelloserver 或者 bin\\wrapper.exe -p ..\\conf\\wrapper.conf cmd结果 服务结果 删除服务命令 sc delete jarhelloserver 或者 bin\\wrapper.exe -r ..\\conf\\wrapper.conf cmd结果 扩展 一由于使用命名操作复杂，故在服务目录创建bat文件 install-service.bat @echo off start cmd /c \"title install-service &amp;&amp; bin\\wrapper.exe -i ..\\conf\\wrapper.conf\"uninstall-service.bat @echo off start cmd /c \"title uninstall-service &amp;&amp; bin\\wrapper.exe -r ..\\conf\\wrapper.conf\"start-service.bat @echo off start cmd /c \"title start-service &amp;&amp; bin\\wrapper.exe -t ..\\conf\\wrapper.conf\"stop-service.bat @echo off start cmd /c \"title stop-service &amp;&amp; bin\\wrapper.exe -p ..\\conf\\wrapper.conf\"扩展 二我们可以用上面的service wrapper的bin包中的bat文件进行服务操作将下载解压后的wrapper-windows\\bin中的部分文件复制到我们的服务\\bin目录下我们只需要点击上面的bat文件即可实现上面的操作： 安装服务：InstallTestWrapper-NT.bat 查询服务：QueryTestWrapper-NT.bat 开启服务：StartTestWrapper-NT.bat 停止服务：StopTestWrapper-NT.bat 测试服务：TestWrapper.bat 卸载服务：UninstallTestWrapper-NT.bat document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Windows10","slug":"Windows10","permalink":"https://www.zhuqiaolun.com/categories/Windows10/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.zhuqiaolun.com/tags/Java/"}]},{"title":"SpringBoot配置restTemplate访问https","slug":"1592881660483-hello","date":"2020-06-23T03:07:40.000Z","updated":"2020-06-23T05:13:40.456Z","comments":true,"path":"2020/06/23/1592881660483-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/06/23/1592881660483-hello/","excerpt":"SpringBoot配置restTemplate访问https","text":"依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependency&gt; &lt;!-- 不需要版本号 --&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt;&lt;/dependency&gt; 配置123456789101112131415161718192021222324252627282930313233import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.conn.ssl.TrustStrategy;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;import org.springframework.web.client.RestTemplate;import javax.net.ssl.SSLContext;import java.security.KeyManagementException;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.cert.X509Certificate;/** * @ClassName: RestConfig * @Description: * @Author: Demon * @Date: 2020/6/1 19:12 */@Configurationclass RestTemplateConfig { @Bean public RestTemplate restTemplate() throws KeyStoreException, NoSuchAlgorithmException, KeyManagementException { TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -&gt; true; SSLContext sslContext = org.apache.http.ssl.SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build(); SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext); CloseableHttpClient httpClient = HttpClients.custom().setSSLSocketFactory(csf).build(); //使用httpclient的factory HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(); requestFactory.setHttpClient(httpClient); return new RestTemplate(requestFactory); }} 测试123456789101112@Slf4j@SpringBootTestclass SpringBootApiApplicationTests { @Resource private RestTemplate restTemplate; @Test void contextLoads(){ String url = \"https://www.baidu.com/\"; String resp = restTemplate.getForObject(url, String.class); System.out.println(resp); }} 结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.zhuqiaolun.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.zhuqiaolun.com/tags/Java/"}]},{"title":"RabbitMq学习三","slug":"1591944668470-hello","date":"2020-06-12T06:51:08.000Z","updated":"2020-06-15T03:11:02.492Z","comments":true,"path":"2020/06/12/1591944668470-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/06/12/1591944668470-hello/","excerpt":"使用交换机topic+routingKey的模式 - 优先级 (spring-boot)","text":"引入的maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; yml配置12345678910111213141516171819202122232425262728spring: rabbitmq: addresses: 127.0.0.1:5672 username: guest password: guest connection-timeout: 15000 virtual-host: / # 开启消息发送到交换器（Exchange）后触发回调 publisher-confirm-type: simple # 开启消息发送到队列（Queue）后触发回调 publisher-returns: true listener: direct: # 开启ACK acknowledge-mode: manual # 开启手动 ，否则confirm自动确认 simple: # 开启ACK # 消息接收确认，可选模式：NONE（不确认）、AUTO（自动确认）、MANUAL（手动确认） acknowledge-mode: manual # 最小线程数量 concurrency: 10 # 最大线程数量 max-concurrency: 10 # 每个消费者可能未完成的最大未确认消息数量 prefetch: 1 template: # 交换机找不到QUEUE时，会调用Basic.Return 命令将消息返回给生产者 mandatory: true 声明绑定关系123456789101112131415161718192021222324252627282930313233343536373839404142/** * 初始化项目 就会创建 交换器，路由，队列，如果在服务中存在交换器的属性或者队列的属性不同，则会出现异常 * @return 返回 */@Configurationpublic class RabbitMqConfig { private static final String PRIORITY_QUEUE_NAME = \"priority.topic_demo\"; private static final String PRIORITY_TOPIC_ROUTING_KEY = \"priority.topic.routingKey\"; private static final String PRIORITY_EXCHANGE_NAME = \"priority.topic.exchange.name\"; /** * 声明消息队列 * @return 返回 */ @Bean(PRIORITY_QUEUE_NAME) public Queue priorityTopicDemo(){ Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(1); arguments.put(\"x-max-priority\", 255); return new Queue(PRIORITY_QUEUE_NAME,true, false, false,arguments); } /** * 声明了一个Topic类型的交换机，durable是持久化（重启rabbitmq这个交换机不会被自动删除） * @return 返回 */ @Bean(PRIORITY_EXCHANGE_NAME) public Exchange priorityTopicExchangeName(){ return ExchangeBuilder.topicExchange(PRIORITY_EXCHANGE_NAME).durable(true).build(); } /** * 声明队列和交换机绑定关系，并且指定RoutingKey * @param queue 队列 * @param exchange 交换机 * @return 返回 */ @Bean public Binding queueBindingTopic(@Qualifier(PRIORITY_QUEUE_NAME) Queue queue,@Qualifier(PRIORITY_EXCHANGE_NAME) Exchange exchange){ return BindingBuilder.bind(queue).to(exchange).with(PRIORITY_TOPIC_ROUTING_KEY).noargs(); }} 生产者123456789101112131415161718192021222324252627@Component@Slf4jpublic class HelloSender { @Resource private RabbitTemplate rabbitTemplate; /** * 通过exchange和routingKey的方式 * rabbitTemplate.sendAndReceive(String exchange, String routingKey, Message message) * @param messageId 消息ID * @param exchange 交换机 * @param routingKey 路由 * @param priority 优先级 * @param content 内容 */ public void sendAndReceive(String messageId, String exchange, String routingKey, Integer priority, String content) { Message message = MessageBuilder.withBody(content.getBytes(Charset.forName(\"UTF-8\"))) .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN) .setMessageId(messageId) .setPriority(priority) .build(); CorrelationData correlationData = new CorrelationData(); correlationData.setId(messageId); this.rabbitTemplate.convertAndSend(exchange, routingKey, message,correlationData); }} 消费者123456789101112131415161718192021222324252627@Component@Slf4jpublic class HelloReceiver { /** * @param message 队列消息对象 */ @RabbitListener(queues = TopicData.PRIORITY_QUEUE_NAME) public void queueNameTest1(Channel channel, Message message) { try { String stringBuilder = \"消息ID: \" + message.getMessageProperties().getMessageId() + \"；\" + \"优先级: \" + message.getMessageProperties().getPriority() + \"；\" + \"消息内容: \" + new String(message.getBody(), StandardCharsets.UTF_8); //告诉服务器收到这条消息 已经被我消费了 可以在队列删掉 这样以后就不会再发了 否则消息服务器以为这条消息没处理掉 后续还会在发 channel.basicAck(message.getMessageProperties().getDeliveryTag(),true); log.info(stringBuilder); } catch (IOException e) { e.printStackTrace(); try { //当发生异常时丢弃这条消息，或者 另行处理 channel.basicNack(message.getMessageProperties().getDeliveryTag(), false,false); System.out.println(\"receiver fail\"); } catch (IOException e1) { e1.printStackTrace(); } } }} 回调自定义 RabbitTemplate.ConfirmCallback 实现类 1234567891011@Slf4jpublic class RabbitConfirmCallBack implements RabbitTemplate.ConfirmCallback{ @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) { log.info(\"收到回调，成功发送到broker\"); log.info(\"消息唯一标识: {}\", correlationData.getId()); log.info(\"确认状态: {}\", ack); log.info(\"造成原因: {}\", cause); }} 自定义 RabbitTemplate.ConfirmCallback 实现类 12345678910111213@Slf4jpublic class RabbitReturnCallback implements RabbitTemplate.ReturnCallback{ @Override public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) { log.info(\"收到回调，交换机找不到队列\"); log.info(\"消息主体: {}\", message); log.info(\"回复编码: {}\", replyCode); log.info(\"回复内容: {}\", replyText); log.info(\"交换器: {}\", exchange); log.info(\"路由键: {}\", routingKey); }} 添加回调，配置 rabbitTemplate 123456789101112@Component@AllArgsConstructorpublic class RabbitTemplateInitializingBean implements InitializingBean { private final RabbitTemplate rabbitTemplate; @Override public void afterPropertiesSet(){ rabbitTemplate.setConfirmCallback(new RabbitConfirmCallBack()); rabbitTemplate.setReturnCallback(new RabbitReturnCallback()); }} 测试123456789101112131415161718@SpringBootTestclass SpringBootRabbitmqExampleApplicationTest { @Resource private HelloSender helloSender; @Test void content(){ Random r = new Random(); int number = 1; for (int i = 0; i &lt; number ; i++) { String messageId = UUID.randomUUID().toString().replace(\"-\",\"\"); String exchange = \"priority.topic.exchange.name\"; String routingKey = \"priority.topic.routingKey\"; Integer priority = r.nextInt(255); String content = \"这是第[\"+i+\"]个消息\"; helloSender.sendAndReceive(messageId, exchange, routingKey, priority, content); } }} 结果： 当删除交换机时的执行错误 当删除队列时的执行错误 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"queue队列","slug":"queue队列","permalink":"https://www.zhuqiaolun.com/categories/queue%E9%98%9F%E5%88%97/"}],"tags":[{"name":"RabbitMq","slug":"RabbitMq","permalink":"https://www.zhuqiaolun.com/tags/RabbitMq/"}]},{"title":"RabbitMq学习二","slug":"1591941634146-hello","date":"2020-06-12T06:00:34.000Z","updated":"2020-06-12T06:50:36.030Z","comments":true,"path":"2020/06/12/1591941634146-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/06/12/1591941634146-hello/","excerpt":"使用交换机topic+routingKey的模式 - 优先级","text":"引入的maven依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt;&lt;/dependency&gt; 生产者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import com.rabbitmq.client.AMQP;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.UUID;import java.util.concurrent.TimeoutException;public class PriorityProducer { public final static String QUEUENAME = \"priority.topic_demo\";// 队列名称 public final static String HOST = \"localhost\"; // 主机名 public final static String USERNAME = \"guest\"; //用户名 public final static String PASSWORD = \"guest\"; //密码 public final static String EXCHANGE_NAME = \"priority.topic.exchange.name\"; //交换机 public final static String ROUTING_KEY = \"priority.topic.routingKey\"; //路由 public static void main(String[] arggs) throws IOException, TimeoutException { ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setPassword(USERNAME); connectionFactory.setUsername(PASSWORD); connectionFactory.setPort(5672); connectionFactory.setHost(HOST); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); // 创建交换机 channel.exchangeDeclare(EXCHANGE_NAME, \"topic\", true); // 创建优先级 Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;(); args.put(\"x-max-priority\", 255);//定义优先级最大值 channel.queueDeclare(QUEUENAME, true, false, false, args); channel.queueBind(QUEUENAME, EXCHANGE_NAME, ROUTING_KEY); // 发送优先级消息 for (int i = 0; i &lt; 10; i++) { AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder(); builder.messageId(UUID.randomUUID().toString()); if (i % 2 != 0) { builder.priority(i); //判断 新增 优先级 }else{ builder.priority(0); } AMQP.BasicProperties properties = builder.build(); System.out.println( (\"messages-\" + i)); channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, properties, (\"messages-\" + i).getBytes()); } channel.close(); connection.close(); System.out.println(\"客户端信息发送完毕！\"); }} 消费者1234567891011121314151617181920212223242526272829303132333435import com.rabbitmq.client.AMQP.BasicProperties;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import java.io.IOException;import java.util.concurrent.TimeoutException;public class PriorityConsumer { public final static String QUEUENAME = \"priority.topic_demo\";// 队列名称 public final static String HOST = \"localhost\"; // 主机名 public final static String USERNAME = \"guest\"; public final static String PASSWORD = \"guest\"; public final static String EXCHANGE_NAME = \"priority.topic.exchange.name\"; public final static String ROUTING_KEY = \"priority.topic.routingKey\"; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException { ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setPassword(PASSWORD); connectionFactory.setUsername(USERNAME); connectionFactory.setPort(5672); connectionFactory.setHost(HOST); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); DefaultConsumer c = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException { System.out.println(properties.getMessageId()+\" - \"+properties.getPriority()+\" - \"+ new String(body)); } }; channel.basicConsume(QUEUENAME, true, c); System.out.println(\"消费端开启···\"); }} 结果：生产者： 消费者：当生产者在适度发送消息消费时 (没有消息积累) 当生产者在过度发送消息消费时 (有消息积累) 具有优先级的先执行操作，先进后出。消费者可多个，当交换机和路由和队列名相同时则不会进行重复消费，在生产者发出消息后会进行轮询分发消费。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"queue队列","slug":"queue队列","permalink":"https://www.zhuqiaolun.com/categories/queue%E9%98%9F%E5%88%97/"}],"tags":[{"name":"RabbitMq","slug":"RabbitMq","permalink":"https://www.zhuqiaolun.com/tags/RabbitMq/"}]},{"title":"RabbitMq学习一","slug":"1591869892000-hello","date":"2020-06-11T10:04:52.000Z","updated":"2020-06-15T02:54:13.702Z","comments":true,"path":"2020/06/11/1591869892000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/06/11/1591869892000-hello/","excerpt":"Windows下RabbitMQ安装及配置","text":"介绍rabbitMQ是一个在AMQP协议标准基础上完整的，可服用的企业消息系统。它遵循Mozilla Public License开源协议，采用 Erlang 实现的工业级的消息队列(MQ)服务器，Rabbit MQ 是建立在Erlang OTP平台上。 安装 Erlang下载地址：​https://www.erlang.org/downloads，下载与系统对应的版本文件安装时，一路 next 即可安装完成设置环境变量， &nbsp;&nbsp;变量名：ERLANG_HOME &nbsp;&nbsp;变量值：D:\\erl-23.0（安装根目录） 修改环境变量path，增加Erlang变量至path，%ERLANG_HOME%\\bin;打开cmd命令框，输入erl至此，Erlang 安装完成 安装 RabbitMq下载地址：https://www.rabbitmq.com/install-windows-manual.html本文选择解压缩安装 rabbitmq-server-windows-3.8.4.zip配置环境变量： &nbsp;&nbsp;变量名：RABBITMQ_SERVER &nbsp;&nbsp;变量值：D:\\rabbitmq_server-3.8.4（安装根目录）打开cmd命令框，进入 安装目录安装插件，命令：rabbitmq-plugins.bat enable rabbitmq_management启动：rabbitmq-server.batrabbitmq启动成功，浏览器中http://localhost:15672，输入guest,guest进入rabbitMQ管理控制台：至此，rabbitMQ安装部署完成。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"queue队列","slug":"queue队列","permalink":"https://www.zhuqiaolun.com/categories/queue%E9%98%9F%E5%88%97/"}],"tags":[{"name":"RabbitMq","slug":"RabbitMq","permalink":"https://www.zhuqiaolun.com/tags/RabbitMq/"}]},{"title":"修改hexo创建文章名称规则","slug":"1591760460000-hello","date":"2020-06-10T03:41:00.000Z","updated":"2020-06-12T06:58:22.108Z","comments":true,"path":"2020/06/10/1591760460000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/06/10/1591760460000-hello/","excerpt":"修改hexo创建文章名称规则","text":"修改hexo的module 添加前缀时间戳新增文章操作： hexo new helloINFO Created: D:\\workspace-webstorm\\demon\\blog\\myblog\\source_posts\\1591933260490-hello.md document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"hexo","slug":"hexo","permalink":"https://www.zhuqiaolun.com/categories/hexo/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"https://www.zhuqiaolun.com/tags/hexo%E4%B8%BB%E9%A2%98/"}]},{"title":"hexo博客收录","slug":"1590766728000-hello","date":"2020-05-29T15:38:48.000Z","updated":"2020-06-12T05:51:27.428Z","comments":true,"path":"2020/05/29/1590766728000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/05/29/1590766728000-hello/","excerpt":"hexo博客被百度收录","text":"​前言​博客，分享才是真理。 HTTPS认证​找到 百度站长平台 -&gt; HTTPS认证认证似乎能加速百度收录速度在认证中，需要下载百度的专属识别文件，放在项目根目录，然后进行测试验证即可配置301 server { listen 80; server_name www.zhuqiaolun.com; if ($scheme = http ) { return 301 https://www.zhuqiaolun.com$request_uri; } location / { root html; index index.html index.htm; } }认证结果： 安装网站地图插件先安装sitemap插件，生成网站地图 npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save12修改配置文件​修改博客根路径下的_config.yml配置文件中的url站点地址 url: https://www.zhuqiaolun.com/ # 在这儿填写你的博客域名 root: / permalink: :year/:month/:day/:title/ permalink_defaults: pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks验证xml文件​执行命令 hexo s 完之后就会在博客路径下生成 sitemap.xml 文件和 baidusitemap.xml 文件，可以通过 https://www.zhuqiaolun.com/baidusitemap.xml 查看该文件是否生成sitemap.xml文件是搜索引擎通用的文件baidusitemap.xml是百度专用的sitemap文件 向百度提交链接​找到 百度站长平台-&gt;普通收录 -&gt; 资源提交 -&gt; sitemap在其中填写百度专用的baidusitemap.xml的请求路径 https://www.zhuqiaolun.com/baidusitemap.xml 收录结果通过认证之后进入baidusitemap提交，响应速度超快，不到5分钟就把链接收录完成 查询收录结果访问 百度站长工具 输入网址地址，点击查询，即可看到结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"hexo","slug":"hexo","permalink":"https://www.zhuqiaolun.com/categories/hexo/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"https://www.zhuqiaolun.com/tags/hexo%E4%B8%BB%E9%A2%98/"}],"author":"Demon"},{"title":"在Linux中安装nginx环境","slug":"1590376771000-hello","date":"2020-05-25T03:19:31.000Z","updated":"2020-06-12T05:48:55.128Z","comments":true,"path":"2020/05/25/1590376771000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/05/25/1590376771000-hello/","excerpt":"在Linux中安装nginx环境","text":"下载nginxnginx 官网下载地址：http://nginx.org/en/download.htmlnginx 文件下载地址：https://nginx.org/download/下载稳定版本即可 上传nginxmkdir /usr/local/software # 创建软件安装目录 cd /usr/local/software # 进入软件安装目录 rz # 上传nginx文件，需要安装 yum install lrzsz ll # 查看上传文件 tar -zxvf nginx-1.18.0.tar.gz # 解压文件到当前目录 检测nginx环境在安装nginx前首先要确认系统中安装了gcc、zlib 、zlib-devel、pcre、pcre-devel、openssl、openssl-develLinux下检查是否安装过某软件包： yum list installed | grep gcc # 查看是否安装了gcc yum list installed | grep pcre yum list installed | grep pcre-devel yum list installed | grep zlib yum list installed | grep zlib-devel yum list installed | grep openssl yum list installed | grep openssl-devel 在此发现只安装了gcc和openssl，其他都没有安装，所以需要安装前置环境，输入以下命令： yum -y install zlib zlib-devel pcre pcre-devel openssl openssl-devel # 一键安装 至此前置软件安装结束，下面进入正式安装nginx 安装nginxcd /usr/local/software/nginx-1.18.0 # 进入nginx的安装根目录 配置nginx安装目录./configure --prefix=/usr/local/nginx # 配置nginx安装目录，执行完成后不会产生nginx目录执行完成后会出现一个 Makefile 的文件 编译并安装make &amp;&amp; make install # 编译、安装，执行完成后会产生nginx目录 cd /usr/local/nginx/ # 进入nginx目录nginx目录内容 测试是否安装成功./sbin/nginx -t出现 test is successful 表示安装成功，同时会生成一些文件 启动nginxcd /usr/local/nginx/sbin # 进入启动目录 ./nginx # 启动nginx，默认读取 /usr/local/nginx/conf 目录下的 nginx.conf 配置文件 ps -ef | grep nginx # 查看nginx是否启动当出现 worker process 则表示运行成功 另 执行命令： ps -A | grep nginx ，如果返回结果的话，也说明有nginx在运行，服务已经启动 访问nginxcurl http://localhost # 默认端口为：80当出现 Welcome to nginx! 则表示访问成功 修改nginx.confcd /usr/local/nginx/conf/ # 进入nginx配置文件目录 vim nginx.conf # 进入编辑文件模式 1234567location / { autoindex on; #打开目录列表 autoindex_exact_size off; #on显示文件的确切大小，off则会用M、G等单位 autoindex_localtime on; #显示文件服务器时间，off显示GMT时间 root html; index index.html index.htm;} 修改完成后使用 /usr/local/nginx/sbin/nginx -t 命令检测语句是否修改正确，如出现 test is successful，则表示正确 扩展/usr/local/nginx/sbin/nginx # 启动服务 /usr/local/nginx/sbin/nginx -s stop # 停止服务 /usr/local/nginx/sbin/nginx -s reload # 重启服务 /usr/local/nginx/sbin/nginx -t # 检测语句 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.zhuqiaolun.com/categories/Linux/"}],"tags":[{"name":"安装软件","slug":"安装软件","permalink":"https://www.zhuqiaolun.com/tags/%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"}],"author":"Demon"},{"title":"使本地git与Github连接","slug":"1590309165000-hello","date":"2020-05-24T08:32:45.000Z","updated":"2020-06-12T05:44:41.823Z","comments":true,"path":"2020/05/24/1590309165000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/05/24/1590309165000-hello/","excerpt":"使本地git与Github连接","text":"创建github账号在 github 中创建一个账号，如有账号则不需创建 配置github账户安装成功后打开Git Bash Here，执行命令 git config –global -e 操作进入全局配置文件 1git config --global -e 按 i 进行编辑以下内容： [user] name = zhuqiaolun # github的Username email =zhuqlchina@163.com # github的Email按下ESC，输入 :wq 保存退出 输入以下命令禁用自动转换，防止 Git 提交时报错warning: LF will be replaced by CRLF in 1git config --global core.autocrlf false 输入以下命令查看配置 1git config -l 生成ssh认证输入以下命令，回车会让你输入存放保存ssh key的地址，它给了一个默认地址就是括号了那里，再回车就是你选择了默认地址，然后会让你输入密码并且确认密码，ok生成了，过程如下图 1ssh-keygen -t rsa -C \"zhuqlchina@163.com\" # github的Email 按照你存放ssk key的地址，去复制key，比如我的在下图这个位置，打开id_rsa.pub,复制里面的key 配置ssh认证登录 github ,setting -&gt; SSH and GPG keys -&gt; new SSH key输入key后 点击 Add SSH key 完成 验证ssh认证在git bash 下输入命令，如在前面设置过密码则会提示输入密码，那输入设置的密码即可 1ssh -T git@github.com 拉去github文件到本地仓库 选好本地仓库的目录，进去鼠标右键-&gt;Git Bash Here,输入以下命令拉去github上面的代码并进入拉去的代码目录 1git clone https://github.com/zhuqiaolun/spring-boot-code # repositories的url 修改内容后则需要提交文件 提交代码到远程仓库输入命令，查看修改了哪些文件，出现的红色字则为修改了内容的文件 1git status 修改文件状态，将本地文件更新全部提交到暂缓区 1.全部修改 1git add . # 更新文件状态，将文件添加到暂存区，注意后面一个点 2.修改只提交的文件 1touch .gitignore # 创建忽略提交的文件 在里面添加 不必要提交的文件路径或者文件名，过滤文件夹设置：.idea 表示过滤这个文件夹过滤文件设置：*.iml 输入命令： 1git add .gitignore # 更新单个文件状态 当前需要的文件变成绿色后，就可以提交了，先提交本地在提交远程，中间有可能要输入用户密码验证 12git commit -m '相关注释文字' #提交到本地仓库git push origin master #提交到远程仓库 查看远程github 扩展从本地上传代码到github上操作：在git bash 下输入命令1、仓库初始化git init2、连接仓库，没有则需新建git remote add origin 仓库地址3、查看状态git status4、将文件添加到暂存区git add 状态里的新文件5、将文件添加到仓库git commit -m’相关注释文字’6、将本地代码提交到远程仓库git push origin master ssh和https提交代码时其实都需要验证，ssh用的是key， https用的是登录名和密码的方式 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Windows10","slug":"Windows10","permalink":"https://www.zhuqiaolun.com/categories/Windows10/"}],"tags":[{"name":"安装软件","slug":"安装软件","permalink":"https://www.zhuqiaolun.com/tags/%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"}],"author":"Demon"},{"title":"Java反射机制","slug":"1590300096000-hello","date":"2020-05-24T06:01:36.000Z","updated":"2020-05-29T17:18:51.898Z","comments":true,"path":"2020/05/24/1590300096000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/05/24/1590300096000-hello/","excerpt":"Java反射机制","text":"什么是反射JAVA反射机制是在运行状态中，对于任意一个类。都能都知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称之为java语言的反射机制； 反射的作用反射类： java.lang.reflect反编译： .class –à .java通过反射机制可以访问java对象中的属性，方法，构造方法，自定义方法 创建Class对象的三种方式实例对象： 1234567891011121314public class Person { private String name; private int age ; // 构造方法（无参，有参） // get 方法·· // set 方法·· // 自定义一个执行方法，方法名称：execute， // 参数1：name，类型：String.class // 参数2：age，类型：int.class public String execute(String name, int age) { return \"姓名:\" + name + \"；年龄：\"+ age; }} 创建Class对象的方式一对象.getClass()，获取Person类中的字节码文件 1Class&lt;?&gt; class1 = new Person().getClass(); 创建Class对象的方式二.class，一个明确的类，任意一个类型都有一个静态的class属性 1Class&lt;?&gt; class2 = Person.class; 创建Class对象的方式三 （推荐）必须是全路径名称，如：com.demon.hello.Person，如找不到则出现异常：ClassNotFoundException 12345try { Class&lt;?&gt; class3 = Class.forName(classPath); } catch (ClassNotFoundException e) { e.printStackTrace(); } 获取类的实例获取class类型之后，可以创建该类型的对象，如：class3.newInstance() 执行类的方法获得class类型的Method对象，根据方法参数定义填写参数类型说明 参数类型与需要反射的类的参数类型保持一致，如int.class不要写成Integer.classinvoke方法，参数为cls实例对象，和想要调用的方法参数输出invoke方法的返回值(返回值类型可为方法定义的返回值类型，强制转化即可) // 第一个参数为方法名,第二个参数为参数name的类型Class对象，第三个参数为参数age的类型Class对象 Method method2 = class3.getMethod(\"execute\", String.class, int.class); Object obj = method1.invoke(c1s.newInstance(), \"张三\", 30); System.out.println(\"execute方法的返回值：\" + value); // 姓名:张三；年龄：30扩展在获取创建类型的对象后，获取根据类的方法判断该执行类是否满足执行条件，如是否有实现接口：c1s.getInterfaces()，返回是一个数组，是否有注解类：c1s.getAnnotation(aCls.class)，参数为注解类.class，更多查看 api ··· document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.zhuqiaolun.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.zhuqiaolun.com/tags/Java/"}],"author":"Demon"},{"title":"在Linux中安装Java环境","slug":"1590236390000-hello","date":"2020-05-23T12:19:50.000Z","updated":"2020-06-12T05:43:14.711Z","comments":true,"path":"2020/05/23/1590236390000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/05/23/1590236390000-hello/","excerpt":"在Linux中安装Java环境","text":"下载JDK由于是安装在服务器，所以只需jre即可，选择对应的系统版本点击下载，没有登陆则跳转登陆页面，此提供一位同学账号： `2028056560@qq.com/Oracle1234 方便使用 （感谢同学） 上传JDK到服务器安装命令 yum install -y lrzsz 工具，此为在Xshell下使用，rz:上传，sz:下载在local下创建java目录，在弹出的窗口中选择要上传的jdk压缩文件，上传文件到Linux上java安装目录并解压，此时安装目录为：/usr/local/java/jdk1.8.0_231 mkdir /use/local/java # 创建目录 cd /use/local/java # 进入目录 rz # 上传文件 tar -zxvf jdk-8u231-linux-x64.tar.gz # 解压文件 配置JDK环境变量使用 vim /etc/profile 命令进入编辑器，添加以下内容： set java environment JAVA_HOME=/usr/local/java/jdk1.8.0_231 JRE_HOME=$JAVA_HOME/jre CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin export JAVA_HOME JRE_HOME CLASS_PATH PATH使用 qw 对内容保存并退出使用 source /etc/profile 让内容生效 验证JDK环境变量使用 java -version 查看环境是否安装完全 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.zhuqiaolun.com/categories/Linux/"}],"tags":[{"name":"安装软件","slug":"安装软件","permalink":"https://www.zhuqiaolun.com/tags/%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"}],"author":"Demon"},{"title":"在idea中创建项目与github关联","slug":"1590142873000-hello","date":"2020-05-22T10:21:13.000Z","updated":"2020-06-12T05:42:01.472Z","comments":true,"path":"2020/05/22/1590142873000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/05/22/1590142873000-hello/","excerpt":"在idea中创建项目与github关联","text":"在IDEA中配置git在IDEA中设置Git，在File–&gt;Setting-&gt;Version Control–&gt;Git ，git安装环境变量成功会自动识别安装路径，点击Test，测试是否设置成功 在IDEA中连接github中心在IDEA中，File–&gt;Setting-&gt;Version Control–&gt;GibHub，点击右侧 “ + “ 按钮，建议在Server的中添加[https://]，Login为Github的账户，Password为Github的密码，点击Log In，成功则显示， 创建本地仓库在IDEA中，VCS–&gt;Import into Version Control–&gt;Create Git Repository 在弹窗中选择项目所在的位置 点击OK，此时项目文件全部变成红色，同时在项目目录下生成一个隐藏的.git的文件目录 上传文件到本地仓库在IDEA中，选择项目鼠标右键–&gt; git –&gt; Add，此时项目文件变成绿色，此时文件只处于本地库的暂存区，并没有同步到github版本库中 同步到本地github版本在IDEA中，选择项目鼠标右键–&gt; git –&gt; Commit Directory，出现提交弹窗，在弹窗勾掉.idea排除不必要的文件，在弹窗中输入Commit Message，否则不允许提交，点击commit，此时项目文件从暂存区真正进入本地github版本库中，项目文件变成白色 上传项目到GitHub中在IDEA中，选择项目，VCS–&gt;Import into Version Control–&gt;Share Project on GitHub，在弹框中自动输入仓库名，输入描述，选择要Share的链接， 点击Share，即可上传，中间会弹窗输入GitHub的用户名和密码（已输入过用户名和密码并记住的不会再次弹框输入），上传成功后IDEA右下角会给出提示 同步结束此至，可访问github上查看 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"工具","slug":"工具","permalink":"https://www.zhuqiaolun.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://www.zhuqiaolun.com/tags/idea/"}],"author":"Demon"},{"title":"在Windows上安装git-v2.26.2","slug":"1590132000000-hello","date":"2020-05-22T07:20:00.000Z","updated":"2020-06-12T05:40:54.205Z","comments":true,"path":"2020/05/22/1590132000000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/05/22/1590132000000-hello/","excerpt":"在Windows上安装git-v2.26.2","text":"下载git下载并安装 git 进入自动识别系统， 点击自动弹出下载窗口 安装git下载结束后，双击进行安装，如已安装点击运行则为修复版本 是否显示桌面图，可不勾选，在安装结束后鼠标右键有选项显示 此项完全不修改PATH变量值，仅在Git Bash中使用Git，绝对安全，所以cmd的git –version 无效 Git命令与Linux一样，所以最好在OpenSSL中操作命令 启用文件缓存 在桌面或者文件目录空白处点击鼠标右键，选择 Git Bash Here 选项，即可打开命令界面 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Windows10","slug":"Windows10","permalink":"https://www.zhuqiaolun.com/categories/Windows10/"}],"tags":[{"name":"安装软件","slug":"安装软件","permalink":"https://www.zhuqiaolun.com/tags/%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"}],"author":"Demon"},{"title":"(图)王者荣耀 - 武则天 - 女帝","slug":"1590066158000-hello","date":"2020-05-21T11:21:02.000Z","updated":"2020-06-23T05:20:58.120Z","comments":false,"path":"2020/05/21/1590066158000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/05/21/1590066158000-hello/","excerpt":"奉我为主！叫我女王陛下！","text":"历史上的TA武则天，名曌(zhào)，这个字，是她自己为自己造的，取明月当空之意。中国历史上的女主不少，但称帝当皇帝的，只有她一个。武则天最初是唐太宗的才人，后与太宗的儿子李治相恋，李治登基后，封为昭仪，进一步被封为皇后。高宗多病，武则天临朝听政，宫中并称二圣。高宗死后，几经折腾，先后废掉两个儿子，武则天剪除了忠于李唐的朝中势力，改国号为周，自立为帝。武则天虽然任用酷吏，鼓励告密，杀了不少朝臣，但为政还算清明，在她当政期间，国家强盛，民众安泰。临死因传位问题无法解决，最终把天下又还给了李家。 女帝 东方不败 海洋之心 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"游戏","slug":"游戏","permalink":"https://www.zhuqiaolun.com/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"王者荣耀","slug":"王者荣耀","permalink":"https://www.zhuqiaolun.com/tags/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80/"}],"author":"王者荣耀"},{"title":"(图)王者荣耀 - 嬴政 - 王者独尊","slug":"1590059618000-hello","date":"2020-05-21T11:13:38.000Z","updated":"2020-06-23T05:20:58.184Z","comments":false,"path":"2020/05/21/1590059618000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/05/21/1590059618000-hello/","excerpt":"向所有人显现的东西，才叫公正。黑色，光明的预演。","text":"历史上的TA嬴政又称秦王政，秦始皇。他是秦朝第一个皇帝，也是秦国的最后一个国王。关于他的出身，有很传奇的经历。他的父亲，本是秦国被遗弃在外的王子，因为赵国富商吕不韦的运作，才得以回国接班。所以，秦王政即位时，称吕不韦为亚父。但是，作为枭雄的嬴政，很快就运用铁腕，从吕不韦的手中夺过了大权，囚禁了信任宦官、秽乱宫廷的母后，放手任用法家信徒，把军国主义政治推向极致，终于灭了六国，一统天下。他是中国大一统帝制王朝的开创者，也是以吏为师的专制文化的倡导者。 王者独尊 摇滚巨星 暗夜贵公子 优雅恋人 白昼王子 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"游戏","slug":"游戏","permalink":"https://www.zhuqiaolun.com/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"王者荣耀","slug":"王者荣耀","permalink":"https://www.zhuqiaolun.com/tags/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80/"}],"author":"王者荣耀"},{"title":"关于使用macleaya主题的修改","slug":"1589770224000-hello","date":"2020-05-18T02:50:24.000Z","updated":"2020-06-12T05:37:04.845Z","comments":true,"path":"2020/05/18/1589770224000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/05/18/1589770224000-hello/","excerpt":"在hexo主题中选择macleaya主题并应用","text":"前言在 hexo 主题中选择 macleaya 主题并应用 字段描述 title 网站标题 浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到 keywords 关键词 作用是告诉搜索引擎本页内容是围绕哪些词展开的 description 内容摘要 一个网页的简要内容概况，描述内容要和页面内容相关 type 网站内容 类型 date 网站内容 时间，由生成页面时自动生成，默认格式为：YYYY-MM-DD author 网站内容 作者 excerpt 网站内容 文章列表时的简介 categories 网站内容 类别 tags 网站内容 标签 内容修改时间显示修改当前默认格式为：YYYY-MM-DD，想要修改为 YYYY-MM-DD HH:mm:ss，则需在将date(page.date) 改为 date(page.date,’YYYY-MM-DD HH:mm:ss’)即可 head.ejs修改在应用过程中发现 layout/_partial/head.ejs的文件中page.content值与page.description重合，当设置content字段时页面内容则变成content的内容，无法显示正常内容，故 page.content 改为：page.description footer.ejs修改此部分修改一些页脚显示，显示自己需要显示的内容 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"hexo","slug":"hexo","permalink":"https://www.zhuqiaolun.com/categories/hexo/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"https://www.zhuqiaolun.com/tags/hexo%E4%B8%BB%E9%A2%98/"}],"author":"Demon"},{"title":"Hello World","slug":"1589344022000-hello","date":"2020-05-13T04:27:02.000Z","updated":"2020-05-29T17:16:48.487Z","comments":true,"path":"2020/05/13/1589344022000-hello/","link":"","permalink":"https://www.zhuqiaolun.com/2020/05/13/1589344022000-hello/","excerpt":"『你好,世界』","text":"『你好,世界』Java1234567public class HelloWorld{ public static void main(String[] args) { System.out.println( \"Hello, World!\" ); }} C12345#include &lt;stdio.h&gt;int main(){ printf(\"Hello, World!\");} Python 31print(\"Hello, World!\") 可以使用单引号’’，双引号”” 或三引号””” “””或’’’ ‘’’ C++123456#include &lt;iostream&gt;using namespace std;int main(){ cout&lt;&lt;\"Hello, World!\"&lt;&lt;endl;} C#12345678910namespace HelloWorld{ class Program { static void Main(string[] args) { System.Console.Write(\"Hello, World!\"); } }} VB12345Module MainFrm Sub Main() System.Console.WriteLine(\"Hello, World!\") End SubEnd Module JavaScript1alert (\"Hello, World!\"); 1document.write(\"Hello, World!\"); PHP123&lt;?php echo 'Hello, world!';?&gt; SQL1SELECT 列名称 FROM 表名称 Object-C12345#import &lt;stdio.h&gt;int main(int argc,const char *argv[]){ printf(\"Hello World\");} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.zhuqiaolun.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://www.zhuqiaolun.com/tags/%E5%85%B6%E4%BB%96/"}],"author":"Demon"}],"categories":[{"name":"hello","slug":"hello","permalink":"https://www.zhuqiaolun.com/categories/hello/"},{"name":"queue队列","slug":"queue队列","permalink":"https://www.zhuqiaolun.com/categories/queue%E9%98%9F%E5%88%97/"},{"name":"Windows10","slug":"Windows10","permalink":"https://www.zhuqiaolun.com/categories/Windows10/"},{"name":"编程语言","slug":"编程语言","permalink":"https://www.zhuqiaolun.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"hexo","slug":"hexo","permalink":"https://www.zhuqiaolun.com/categories/hexo/"},{"name":"Linux","slug":"Linux","permalink":"https://www.zhuqiaolun.com/categories/Linux/"},{"name":"工具","slug":"工具","permalink":"https://www.zhuqiaolun.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"游戏","slug":"游戏","permalink":"https://www.zhuqiaolun.com/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"hello","slug":"hello","permalink":"https://www.zhuqiaolun.com/tags/hello/"},{"name":"kafka","slug":"kafka","permalink":"https://www.zhuqiaolun.com/tags/kafka/"},{"name":"Java","slug":"Java","permalink":"https://www.zhuqiaolun.com/tags/Java/"},{"name":"RabbitMq","slug":"RabbitMq","permalink":"https://www.zhuqiaolun.com/tags/RabbitMq/"},{"name":"hexo主题","slug":"hexo主题","permalink":"https://www.zhuqiaolun.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"安装软件","slug":"安装软件","permalink":"https://www.zhuqiaolun.com/tags/%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"},{"name":"idea","slug":"idea","permalink":"https://www.zhuqiaolun.com/tags/idea/"},{"name":"王者荣耀","slug":"王者荣耀","permalink":"https://www.zhuqiaolun.com/tags/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80/"},{"name":"其他","slug":"其他","permalink":"https://www.zhuqiaolun.com/tags/%E5%85%B6%E4%BB%96/"}]}